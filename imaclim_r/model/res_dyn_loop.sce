// Imaclim MAIN LOOP //
//==inputs==
//TimeHorizon       : real. last year
//metaRecMessOn : boolean. activates messages
//Calibrations must be done
//!!!This list is not complete
//
// meant to be called by imaclimr.sce or delayed_imaclim.sce,
// as you can see by searching res_dyn_loop.sce in all files (Alt+Q in Notepadd++. Mind the folder)
//////////////////////////////////////////////////////////////////

//This will be set to %t if the "while substep<1 do" leads to toomanysubdivisions
wastooManysubs = %f;
wasError       = %f; //This one will be set to true in various error cases
//ERROR and TOOMANYSUBS MANAGEMENT IS NOT FULLY OPERATIONAL

sg_add(["tax_min"; "tax_max";"objLast";"emiLast";"taxLast";"nbCapTaxes"]);

equilibrium_lastgood = equilibrium;
equilibrium_prev     = equilibrium;
equi_prev_prev       = equilibrium;

emi_eviteeLast = zeros(reg,1);

current_time_im = 0; 
current_time = current_time_im;

exec(MODEL+"extraction."+ETUDEOUTPUT+".init.sce");

for current_time_im = 1:TimeHorizon
    if current_time_im > TimeHorizon
        break;
    end
    if ~wasError
        //initializes equilibrium_prev
        equi_prev_prev   = equilibrium_prev;
        equilibrium_prev = equilibrium;

        taxLast = get_taxes(equilibrium_prev);
        tax_min = taxLast * cff_taxmin;
        tax_max = taxLast+max(taxmax_val*1e-6 , taxLast*cff_taxmax);
        nbCapTaxes = 0;

        for m=1:nbMKT
            emiLast(m) = sum(E_reg_use(whichMKT_reg_use==m)) + sum(emi_eviteeLast(whichMKT_reg_use(:,1)==m));
            objLast(m) = CO2_obj_MKT(m,current_time_im);
            message("For market "+m+", emiLast: "+round(emiLast(m)/1e6)/1e3+"G, emiNeg: "+round( sum(emi_eviteeLast(whichMKT_reg_use(:,1)==m))/1e6)/1e3+"G, objLast: "+round(objLast(m)/1e6)/1e3+"G and tax: "+taxLast(m)*1e6);
        end
        message("For the world emiLast: "+round( sum(emiLast(:))/1e6)/1e3+"G");
        message("===========================================================================\n");
        message("Computing " + (base_year_simulation+current_time_im) + " technical coefficients");
        exec("store_prev.sce");
        exec("dynamic.sce");
        emi_eviteeLast = emi_evitee;
        exec("store_obj.sce");
        substep   = 1;
        step_size = 1;

        is_tryexotax_mode  = %f;
        flag_firsttryexo   = %f;
        last_found_substep =  0;

	first_try=%t;	

        //stores exotaxes generated by choose_exotaxes
        exotaxes = zeros(1:nbMKT)+%nan;

        //loop on substep
        while last_found_substep<1

            exec("step_param.sce");
            say substep step_size last_found_substep
            //chooses guess
            if first_try
		guess=equilibrium;
		first_try=%f;
	    else
		guess=equilibrium;
            	//[guess, flag_firsttryexo] = guess_next_equilibrium(equilibrium_lastgood,equilibrium_prev,equi_prev_prev,last_found_substep,substep,flag_firsttryexo,exotaxes,is_tryexotax_mode,is_taxexo_MKTparam,taxMKT);
	    end
	    if current_time_im>=2020-base_year_simulation
	       [guess, flag_firsttryexo] = guess_next_equilibrium(equilibrium_lastgood,equilibrium_prev,equi_prev_prev,last_found_substep,substep,flag_firsttryexo,exotaxes,is_tryexotax_mode,is_taxexo_MKTparam,taxMKT);
            elseif flag_firsttryexo // at least reset flag_firsttryexo if true
               flag_firsttryexo = %f;
	    end
            //premier essai libre
            [equilibrium, v, info] = solve_equilibrium(guess,equi_function);
            say ("max(abs(v))" ,"info")

            //cap taxes
            if (max(abs(v))<sensibility) & ~is_tryexotax_mode //equi found
                //boucle si la taxe depasse les bornes, ajuster la taxe aux bonres
                while or(areEmisConstparam(:) & (get_taxes(equilibrium)<tax_min | get_taxes(equilibrium)>tax_max))
                    if nbCapTaxes < nbCapTaxesMax
                        nbCapTaxes = nbCapTaxes + 1 ;
                        [equilibrium,areEmisConstparam,is_taxexo_MKTparam] = cap_taxes(equilibrium,tax_min,tax_max,areEmisConstparam,is_taxexo_MKTparam);
                        //do NOT put solve_equilibrium in a function, updateparams() will take the "global" value of is_taxexo_MKTparam and areEmisConstparam

                        [equilibrium,v,info] = solve_equilibrium(equilibrium,equi_function);
                        // restablishes areEmisConstparam and is_taxexo_MKTparam
                        areEmisConstparam  = bool2s(is_quota_MKT);
                        is_taxexo_MKTparam = bool2s(is_taxexo_MKT);
                    else
                        message("Too many captaxes. Entering exotax mode + guess = prev....")
                        //previent les fonctions de resdynloop
                        flag_firsttryexo  = %t;
                        is_tryexotax_mode = %t;
                        //previent le statique que les taxes sont exo
                        is_taxexo_MKTparam(:) = 1;
                        areEmisConstparam(:)  = 0;
                        exotaxes = choose_exotaxes(objLast,emiLast,tax_min,tax_max,taxLast);
                    end
                end
            end

            //this is not an else, v has changed    
            if (max(abs(v))<sensibility) //equi found
                message("found!")
                last_found_substep = substep;
                equilibrium_lastgood = equilibrium;
            else  //equi NOT found
                if step_size<2^(-nbSubdivisionsMax)
                    if ~is_tryexotax_mode& ~is_bau
                        message("Too many subdivisions. Entering exotax mode + guess = prev....")
                        //previent les fonctions de resdynloop
                        flag_firsttryexo  = %t;
                        is_tryexotax_mode = %t;
                        //previent le statique que les taxes sont exo
                        is_taxexo_MKTparam(:) = 1;
                        areEmisConstparam(:)  = 0;
                        exotaxes = choose_exotaxes(objLast,emiLast,tax_min,tax_max,taxLast);
                    else
                        mkalert("error");
                        message("...too many subdivisions again. I give up.");
                        wasError       = %t;
                        wastooManysubs = %t;
                        break
                    end
                end
            end

            [substep, step_size, last_found_substep] = choose_substep(last_found_substep,substep,step_size,flag_firsttryexo);


        end //closes loop on substep
        taxMKT = get_taxes(equilibrium);
        message("obtained precision: "+norm(v,15))

        // restablishes areEmisConstparam and is_taxexo_MKTparam  (useful when exotax mode the previous year)
        areEmisConstparam  = bool2s(is_quota_MKT) ;
        is_taxexo_MKTparam = bool2s(is_taxexo_MKT);

        exec("extraction-generic.sce");

        sg_update(current_time_im+1); //save_generic.sci : update (this also calls sg_init the fisrt time

        exec("plugins.sce");

        if wasError
            sg_save(); //sauvegarde de save_generic.sci
            mksav("investment");

            last_done_year = current_time_im+base_year_simulation;
            mksav ([ "last_done_year" "wastooManysubs" ])
            run_id
            warning ("save_generic has been executed. Last columns can be used to understand why there are too many subdivisions, but not as a model result.")
            exec ( "extraction."+ETUDEOUTPUT+".sce");
            mkalert ( "done");
            disp(run_id,SAVEDIR,"extraction done, results are located in:");
            else
             last_done_year = current_time_im+base_year_simulation+1;
             mksav ("last_done_year");
        end
    end
end
