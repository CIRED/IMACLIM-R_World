// =============================================
// Contact: <imaclim.r.world@gmail.com>
// Licence: AGPL-3.0
// Authors:
//     Florian Leblanc, Ruben Bibas
//     (CIRED - CNRS/AgroParisTech/ENPC/EHESS/CIRAD)
// =============================================

// Imaclim MAIN LOOP //
//==inputs==
//TimeHorizon       : real. last year
//Calibrations must be done
//!!!This list is not complete
//
// meant to be called by imaclimr.sce or delayed_imaclim.sce,
// as you can see by searching res_dyn_loop.sce in all files (Alt+Q in Notepadd++. Mind the folder)
//////////////////////////////////////////////////////////////////

//This will be set to %t if the "while substep<1 do" leads to toomanysubdivisions
wastooManysubs = %f;
wasError       = %f; //This one will be set to true in various error cases
//ERROR and TOOMANYSUBS MANAGEMENT IS NOT FULLY OPERATIONAL

sg_add(["tax_min"; "tax_max";"objLast";"emiLast";"taxLast";"nbCapTaxes"]);

equilibrium_lastgood = equilibrium;
equilibrium_prev     = equilibrium;
equi_prev_prev       = equilibrium;

emi_eviteeLast = zeros(reg,1);

current_time_im = 0; 
current_time = current_time_im;

exec(MODEL+"extraction."+ETUDEOUTPUT+".init.sce");

for current_time_im = 1:TimeHorizon
    if current_time_im > real_TimeHorizon
        break;
    end
    if ~wasError
        //initializes equilibrium_prev
        equi_prev_prev   = equilibrium_prev;
        equilibrium_prev = equilibrium;

        taxLast = get_taxes(equilibrium_prev);
        tax_min = taxLast * cff_taxmin;
        tax_max = taxLast+max(taxmax_val*1e-6 , taxLast*cff_taxmax);
        nbCapTaxes = 0;

        for m=1:nbMKT
            emiLast(m) = sum(E_reg_use(whichMKT_reg_use==m)) + sum(emi_eviteeLast(whichMKT_reg_use(:,1)==m));
            objLast(m) = CO2_obj_MKT(m,current_time_im);
            message("  ");
            message("For market "+m+", emiLast: "+round(emiLast(m)/1e6)/1e3+"G, emiNeg: "+round( sum(emi_eviteeLast(whichMKT_reg_use(:,1)==m))/1e6)/1e3+"G, objLast: "+round(objLast(m)/1e6)/1e3+"G and tax: "+taxLast(m)*1e6);
        end
        message("For the world emiLast: "+round( sum(emiLast(:))/1e6)/1e3+"G");
        message("===========================================================================");
        printf('\n');
        message("Computing " + (base_year_simulation+current_time_im) + " year");
        message("    1/ Recursive Dynamic: computing new dynamic parameters");
        exec("store_prev.sce");
        exec("dynamic.sce");
        emi_eviteeLast = emi_evitee;
        exec("store_obj.sce");
        substep   = 1;
        step_size = 1;

        is_tryexotax_mode  = %f;
        flag_firsttryexo   = %f;
        last_found_substep =  0;

        first_try=%t;	

        //stores exotaxes generated by choose_exotaxes
        exotaxes = zeros(1:nbMKT)+%nan;

        printf("\n")
        message("    2/ Static equilibrium computation from dynamic parameters");
        //loop on substep
        while last_found_substep<1
            exec("step_param.sce");
            message("        substep = "+string(substep)+", step_size = "+string(step_size)+", last_found_substep = "+string(last_found_substep));
            //chooses guess
            if first_try
                guess=equilibrium;
                first_try=%f;
            else
                guess=equilibrium;
                //[guess, flag_firsttryexo] = guess_next_equilibrium(equilibrium_lastgood,equilibrium_prev,equi_prev_prev,last_found_substep,substep,flag_firsttryexo,exotaxes,is_tryexotax_mode,is_taxexo_MKTparam,taxMKT);
            end
            if current_time_im>=2020-base_year_simulation
                [guess, flag_firsttryexo] = guess_next_equilibrium(equilibrium_lastgood,equilibrium_prev,equi_prev_prev,last_found_substep,substep,flag_firsttryexo,exotaxes,is_tryexotax_mode,is_taxexo_MKTparam,taxMKT);
            elseif flag_firsttryexo // at least reset flag_firsttryexo if true
                flag_firsttryexo = %f;
            end
            //First trial
            [equilibrium, v, info] = solve_equilibrium(guess,equi_function);
            message("                max(abs(v)) is:" + string(max(abs(v))) + ", info: " + string(info));
            //Try other values of starting point: prev, prev_prev, and random shocks
            if (max(abs(v))>=sensibility)
                message("            Trying a different starting eq.: equilibrium_prev");
                [equilibrium, v, info] = solve_equilibrium(equilibrium_prev,equi_function);
            end
            if (max(abs(v))>=sensibility)
                message("            Trying a different starting eq.: equilibrium_prev_prev");
                [equilibrium, v, info] = solve_equilibrium(equi_prev_prev,equi_function);
            end
            if (max(abs(v))>=sensibility)
                message("            Trying a different starting eq.: random shocks");
                for i=[linspace(0.01,0.1,10), linspace(-0.01,-0.1,10)]
                    message("            with random shocks on equilibrium_lastgood: " + i);
                    [equilibrium, v, info] = solve_equilibrium((1+i)*equilibrium_lastgood,equi_function);
                    if (max(abs(v))<sensibility)
                        break;
                    end
                end
            end

            //cap taxes
            if (max(abs(v))<sensibility) & ~is_tryexotax_mode //equi found
                //loop if the carbon taxe is outside range, we then adjust the bounds
                while or(areEmisConstparam(:) & (get_taxes(equilibrium)<tax_min | get_taxes(equilibrium)>tax_max))
                    if nbCapTaxes < nbCapTaxesMax
                        nbCapTaxes = nbCapTaxes + 1 ;
                        [equilibrium,areEmisConstparam,is_taxexo_MKTparam] = cap_taxes(equilibrium,tax_min,tax_max,areEmisConstparam,is_taxexo_MKTparam);
                        //do NOT put solve_equilibrium in a function, updateparams() will take the "global" value of is_taxexo_MKTparam and areEmisConstparam

                        [equilibrium,v,info] = solve_equilibrium(equilibrium,equi_function);
                        // restablishes areEmisConstparam and is_taxexo_MKTparam
                        areEmisConstparam  = bool2s(is_quota_MKT);
                        is_taxexo_MKTparam = bool2s(is_taxexo_MKT);
                    else
                        message("        Too many captaxes. Entering exotax mode + guess = prev....");
                        //Warn resdynloop functions
                        flag_firsttryexo  = %t;
                        is_tryexotax_mode = %t;
                        //Warn the static equilibrium that CO2 taxes are exogenous for this timestep
                        is_taxexo_MKTparam(:) = 1;
                        areEmisConstparam(:)  = 0;
                        exotaxes = choose_exotaxes(objLast,emiLast,tax_min,tax_max,taxLast);
                    end
                end
            end

            //this is not an else, v has changed    
            if (max(abs(v))<sensibility) //equi found
                message("        -> Equilibrium Has Been found!");
                last_found_substep = substep;
                equilibrium_lastgood = equilibrium;
            else  //equi NOT found
                if step_size<2^(-nbSubdivisionsMax)
                    if ~is_tryexotax_mode& ~is_bau
                        message("        Too many subdivisions. Entering exotax mode + guess = prev....")
                        //Warn resdynloop functions
                        flag_firsttryexo  = %t;
                        is_tryexotax_mode = %t;
                        //Warn the static equilibrium that CO2 taxes are exogenous for this timestep
                        is_taxexo_MKTparam(:) = 1;
                        areEmisConstparam(:)  = 0;
                        exotaxes = choose_exotaxes(objLast,emiLast,tax_min,tax_max,taxLast);
                    else
                        mkalert("error");
                        message("        ...too many subdivisions again. I give up.");
                        wasError       = %t;
                        wastooManysubs = %t;
                        break
                    end
                end
            end

            [substep, step_size, last_found_substep] = choose_substep(last_found_substep,substep,step_size,flag_firsttryexo);


        end //closes loop on substep
        taxMKT = get_taxes(equilibrium);
        message("             With an obtained precision: "+norm(v,15));

        // restablishes areEmisConstparam and is_taxexo_MKTparam  (useful when exotax mode the previous year)
        areEmisConstparam  = bool2s(is_quota_MKT) ;
        is_taxexo_MKTparam = bool2s(is_taxexo_MKT);

        exec("extraction-generic.sce");

        exec("plugins.sce");

        sg_update(current_time_im+1); //save_generic.sci : update (this also calls sg_init the fisrt time

        if wasError
            sg_save(); //saving with save_generic.sci
            mksav("investment");

            last_done_year = current_time_im+base_year_simulation;
            mksav ([ "last_done_year" "wastooManysubs" ])
            run_id
            warning ("save_generic has been executed. Last columns can be used to understand why there are too many subdivisions, but not as a model result.")
            exec ( "extraction."+ETUDEOUTPUT+".sce");
            mkalert ( "done");
            disp(run_id,SAVEDIR,"extraction done, results are located in:");
        else
            last_done_year = current_time_im+base_year_simulation+1;
            mksav ("last_done_year");
        end
    end
end
